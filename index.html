<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Camera + Duck Overlay Test (Play/Stop + HUD + LogCopy)</title>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
  #wrap { position:relative; width:100vw; height:100vh; background:#000; }
  #video {
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    background:#000;
    z-index:0;
  }
  #renderCanvas {
    position:absolute; inset:0;
    width:100%; height:100%;
    z-index:1;
    touch-action:none;
    background:transparent;
  }
  #hudBar {
    position:fixed; left:8px; right:8px; bottom:10px;
    z-index:5;
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    pointer-events:auto;
  }
  .btn {
    font-size:14px; padding:10px 12px; border-radius:10px;
    border:1px solid rgba(255,255,255,0.25);
    background:rgba(0,0,0,0.55); color:#fff;
  }
  .btn:active { transform:scale(0.98); }
  #dbg {
    position:fixed; left:8px; top:8px; right:8px;
    z-index:6;
    padding:10px;
    font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    color:#0f0;
    background:rgba(0,0,0,0.6);
    border:1px solid rgba(0,255,0,0.25);
    border-radius:12px;
    white-space:pre-wrap;
    display:none;
    max-height:45vh;
    overflow:auto;
  }
  #toast {
    position:fixed; left:50%; bottom:70px; transform:translateX(-50%);
    z-index:7; padding:8px 10px; border-radius:10px;
    background:rgba(0,0,0,0.7); color:#fff; font-size:13px;
    display:none;
  }
</style>
</head>

<body>
<div id="wrap">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="renderCanvas"></canvas>

  <div id="dbg"></div>
  <div id="toast"></div>

  <div id="hudBar">
    <div style="display:flex; gap:10px; align-items:center;">
      <button class="btn" id="btnCamera">Camera</button>
      <button class="btn" id="btnPlay">Play</button>
      <button class="btn" id="btnStop">Stop</button>
    </div>
    <div style="display:flex; gap:10px; align-items:center;">
      <button class="btn" id="btnDebug">HUD Debug</button>
      <button class="btn" id="btnCopy">Log Copy</button>
    </div>
  </div>
</div>

<script>
/** ====== CONFIG ====== **/
const GLB_NAME = "Duck1.glb"; // ←あなたのGLB名に合わせる
const LOG_MAX = 400;

/** ====== STATE ====== **/
let videoStream = null;
let engine = null, scene = null;
let duckLoaded = false;
let animGroups = [];
let logBuf = [];
let debugOn = false;
let cameraReady = false;

/** ====== LOG ====== **/
function log(...args){
  const msg = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
  const line = `[${new Date().toISOString()}] ${msg}`;
  logBuf.push(line);
  if (logBuf.length > LOG_MAX) logBuf.shift();
  if (debugOn) renderDebug();
  console.log(...args);
}
function toast(s){
  const t = document.getElementById("toast");
  t.textContent = s;
  t.style.display = "block";
  setTimeout(()=> t.style.display="none", 1200);
}
function renderDebug(){
  const dbg = document.getElementById("dbg");
  const parts = [];
  parts.push(`=== STATE ===`);
  parts.push(`cameraReady: ${cameraReady}`);
  parts.push(`duckLoaded:  ${duckLoaded}`);
  parts.push(`engine:      ${!!engine}`);
  parts.push(`scene:       ${!!scene}`);
  parts.push(`animGroups:  ${animGroups.length}`);
  if (engine){
    parts.push(`fps:         ${engine.getFps().toFixed(1)}`);
    const caps = engine.getCaps();
    parts.push(`renderer:    ${engine.getGlInfo().renderer || "?"}`);
    parts.push(`webgl2:      ${caps.supportsWebGL2}`);
  }
  parts.push(`\n=== LAST LOGS (tail 30) ===`);
  parts.push(logBuf.slice(-30).join("\n"));
  dbg.textContent = parts.join("\n");
}

/** ====== CAMERA (Stage 1) ====== **/
async function startCamera(){
  if (cameraReady) { toast("Camera: already"); return; }

  const video = document.getElementById("video");

  // 背面カメラ：exactが失敗する機種もあるのでフォールバック込み
  let stream = null;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } },
      audio: false
    });
  } catch (e1) {
    log("getUserMedia exact env failed:", String(e1));
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" },
        audio: false
      });
    } catch (e2) {
      log("getUserMedia env fallback failed:", String(e2));
      alert("Camera start failed. Check permissions / HTTPS / device.");
      return;
    }
  }

  videoStream = stream;
  video.srcObject = stream;

  // playsinline強制
  try { await video.play(); } catch (e) { log("video.play failed:", String(e)); }

  cameraReady = true;
  log("Camera started. Track:", stream.getVideoTracks()[0]?.label || "?");
  toast("Camera OK");
  if (debugOn) renderDebug();
}

/** ====== BABYLON (Stage 2) ====== **/
async function initBabylonIfNeeded(){
  if (engine && scene) return;

  const canvas = document.getElementById("renderCanvas");
  engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: false,
    stencil: false,
    disableWebGL2Support: false
  });

  scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0,0,0,0); // 透明（ビデオが下）

  // 2D重ね表示なので、操作不要なら attachControl は外してもOK
  const cam = new BABYLON.ArcRotateCamera("cam",
    Math.PI/2, Math.PI/2.2, 2.2,
    BABYLON.Vector3.Zero(), scene);
  cam.lowerRadiusLimit = 0.6;
  cam.upperRadiusLimit = 6.0;
  cam.attachControl(canvas, true);

  new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

  engine.runRenderLoop(() => {
    if (scene) scene.render();
    if (debugOn) renderDebug();
  });

  window.addEventListener("resize", () => engine?.resize());

  log("Babylon initialized.");
}

/** ====== LOAD DUCK ====== **/
async function loadDuckIfNeeded(){
  if (duckLoaded) return;

  await initBabylonIfNeeded();

  try {
    const res = await BABYLON.SceneLoader.ImportMeshAsync(
      null, "./", GLB_NAME, scene
    );

    // アニメグループ取得
    animGroups = scene.animationGroups ? [...scene.animationGroups] : [];
    duckLoaded = true;

    log("Duck GLB loaded:", GLB_NAME, "meshes:", res.meshes?.length || 0, "animGroups:", animGroups.length);

    // === SCALE FIX (make GLB visible) ===
scene.meshes.forEach(m => {
  if (m.name !== "__root__") {
    m.scaling.set(12, 12, 12);  // 50は目安。小さければ100、大きければ20
  }
});
log(`Scale applied: x50`);
    // 見えやすく：中心寄せ
    // ImportMeshAsync は root が入ることがあるので、全体bboxから軽く調整
    try {
      const meshes = res.meshes.filter(m => m && m.getTotalVertices && m.getTotalVertices() > 0);
      if (meshes.length){
        const bbox = meshes[0].getHierarchyBoundingVectors(true);
        const center = bbox.min.add(bbox.max).scale(0.5);
        meshes.forEach(m => m.position = m.position.subtract(center));
      }
    } catch(e){ log("center adjust skipped:", String(e)); }

    toast("Duck Loaded");
  } catch (e) {
    log("Duck load failed:", String(e));
    alert("GLB load failed. Check file name/path and GitHub Pages serving.");
  }
}

/** ====== PLAY / STOP ====== **/
async function playDuck(){
  // 二段階：カメラが先
  if (!cameraReady){
    toast("Start Camera first");
    return;
  }

  await loadDuckIfNeeded();
  if (!duckLoaded) return;

  if (!animGroups.length){
    log("No animationGroups in GLB.");
    toast("No anim");
    return;
  }

  // 全アニメをループ再生
  animGroups.forEach(g => {
    // start(loop, speedRatio, from, to)
    try { g.start(true); } catch(e){ log("anim start err:", String(e)); }
  });

  log("Play pressed: animation started.");
  toast("Play");
}

function stopDuck(){
  if (!duckLoaded || !animGroups.length){
    toast("Stop: not loaded");
    return;
  }
  animGroups.forEach(g => {
    try { g.stop(); } catch(e){ log("anim stop err:", String(e)); }
  });
  log("Stop pressed: animation stopped.");
  toast("Stop");
}

/** ====== DEBUG / COPY ====== **/
function toggleDebug(){
  debugOn = !debugOn;
  const dbg = document.getElementById("dbg");
  dbg.style.display = debugOn ? "block" : "none";
  log("HUD Debug:", debugOn ? "ON" : "OFF");
  if (debugOn) renderDebug();
}

async function copyLogs(){
  const text =
`=== Camera+Duck Overlay Logs ===
UA: ${navigator.userAgent}
secureContext: ${isSecureContext}
cameraReady: ${cameraReady}
duckLoaded: ${duckLoaded}
engine: ${!!engine}
animGroups: ${animGroups.length}

--- LOGS ---
${logBuf.join("\n")}
`;
  try{
    await navigator.clipboard.writeText(text);
    toast("Copied");
  }catch(e){
    // フォールバック：textarea選択
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand("copy"); toast("Copied"); }
    catch(e2){ alert("Copy failed. Long-press to select manually."); }
    document.body.removeChild(ta);
  }
}

/** ====== HOOK UI ====== **/
document.getElementById("btnCamera").addEventListener("click", startCamera);
document.getElementById("btnPlay").addEventListener("click", playDuck);
document.getElementById("btnStop").addEventListener("click", stopDuck);
document.getElementById("btnDebug").addEventListener("click", toggleDebug);
document.getElementById("btnCopy").addEventListener("click", copyLogs);

// 初期ログ
log("Boot. Ready. GLB:", GLB_NAME);
</script>
</body>
</html>
